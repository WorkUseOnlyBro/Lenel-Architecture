```markdown
# Containerizing RabbitMQ with Podman
**Implementation Guide and Analysis**

**Prepared by:** [Your Name]  
**Date:** January 14, 2026  
**Document Version:** 1.0

---

## Executive Summary

This document provides a comprehensive analysis and implementation guide for containerizing RabbitMQ using Podman as an alternative to traditional virtual machine deployments. Podman offers a secure, daemonless container runtime that is compatible with Docker images while providing enhanced security features and integration with systemd.

**Key Benefits:**
- Rapid deployment and scalability
- Consistent configuration across environments
- Resource isolation and efficiency
- Simplified backup and disaster recovery
- Enhanced security through rootless containers

**Recommended Use Cases:**
- Development and testing environments
- Microservices architectures
- Cloud-native deployments
- Environments requiring enhanced security posture

---

## Table of Contents

1. [What is Podman?](#what-is-podman)
2. [Benefits of Containerizing RabbitMQ](#benefits-of-containerizing-rabbitmq)
3. [Challenges and Considerations](#challenges-and-considerations)
4. [Prerequisites](#prerequisites)
5. [Installation Guide](#installation-guide)
6. [Single Instance Deployment](#single-instance-deployment)
7. [Cluster Deployment](#cluster-deployment)
8. [Production Configuration](#production-configuration)
9. [Backup and Recovery](#backup-and-recovery)
10. [Monitoring and Maintenance](#monitoring-and-maintenance)
11. [Troubleshooting](#troubleshooting)
12. [Migration from VM to Container](#migration-from-vm-to-container)

---

## What is Podman?

### Overview

**Podman (Pod Manager)** is a daemonless container engine for developing, managing, and running OCI (Open Container Initiative) containers on Linux systems. Developed by Red Hat, Podman provides a Docker-compatible command-line interface while offering significant architectural and security improvements.

### Key Characteristics

| Feature | Podman | Docker |
|---------|--------|--------|
| Architecture | Daemonless | Daemon-based |
| Root Requirement | Rootless capable | Requires root daemon |
| Systemd Integration | Native | Via third-party tools |
| Pod Support | Native (Kubernetes-style) | Requires Compose/Swarm |
| Command Compatibility | Docker-compatible CLI | Native |
| Security Model | Rootless by default | Root by default |

### Why Podman for RabbitMQ?

1. **Security**: Rootless containers reduce attack surface
2. **Systemd Integration**: Native service management and auto-restart
3. **Pod Support**: Easy multi-container orchestration for clustering
4. **Resource Efficiency**: No daemon overhead
5. **Enterprise Support**: Red Hat backing and RHEL integration

---

## Benefits of Containerizing RabbitMQ

### 1. Deployment Speed and Consistency

**Traditional VM Deployment:**
- OS installation: 30-60 minutes
- RabbitMQ installation: 15-30 minutes
- Configuration: 30-60 minutes
- **Total:** 1.5-2.5 hours per node

**Container Deployment:**
- Pull image: 2-5 minutes
- Start container: < 30 seconds
- Configuration: 5-10 minutes (automated)
- **Total:** 10-15 minutes per node

**Consistency Benefits:**
- Identical configuration across all environments
- Version-locked dependencies
- Reproducible deployments
- Infrastructure as Code (IaC) compatibility

### 2. Resource Efficiency

**Resource Comparison:**

| Deployment Type | Memory Overhead | Disk Space | Boot Time |
|-----------------|-----------------|------------|-----------|
| Virtual Machine | 2-4 GB (OS + RabbitMQ) | 20-40 GB | 2-5 minutes |
| Container | 512 MB - 2 GB (RabbitMQ only) | 500 MB - 2 GB | 5-10 seconds |

**Density Benefits:**
- Run 3-4 containers per VM resource footprint
- Faster startup enables rapid scaling
- Efficient resource utilization through cgroups

### 3. Simplified Configuration Management

**Configuration as Code:**
```yaml
# rabbitmq-config.yml
version: '3.8'
services:
  rabbitmq:
    image: docker.io/rabbitmq:3.12-management
    environment:
      - RABBITMQ_DEFAULT_USER=admin
      - RABBITMQ_DEFAULT_PASS=secure_password
      - RABBITMQ_VM_MEMORY_HIGH_WATERMARK=0.6
    volumes:
      - rabbitmq-data:/var/lib/rabbitmq
      - ./rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf:ro
    ports:
      - "5672:5672"
      - "15672:15672"
```

**Benefits:**
- Version controlled configuration
- Easy rollback to previous configurations
- Automated deployment through CI/CD
- Environment-specific configuration through variables

### 4. Isolation and Multi-tenancy

**Namespace Isolation:**
- Process isolation through Linux namespaces
- Network isolation through virtual networks
- Filesystem isolation through overlay storage
- Resource limits through cgroups

**Use Cases:**
- Multiple RabbitMQ versions on same host
- Development/staging/production on same infrastructure
- Multi-tenant environments with resource guarantees

### 5. Backup and Disaster Recovery

**Container-based Backups:**
```bash
# Backup container data
podman volume export rabbitmq-data > rabbitmq-backup-$(date +%Y%m%d).tar

# Backup configuration
podman inspect rabbitmq > rabbitmq-config-backup.json

# Complete container export
podman export rabbitmq > rabbitmq-container-backup.tar
```

**Benefits:**
- Snapshot-based backups (< 1 minute)
- Point-in-time recovery
- Portable backups across environments
- Simplified DR testing

### 6. Development-Production Parity

**Consistent Environments:**
- Developers run identical images locally
- CI/CD uses same images for testing
- Production uses verified images
- Eliminates "works on my machine" issues

**Version Management:**
```bash
# Development
podman run rabbitmq:3.12-management

# Staging
podman run rabbitmq:3.12.10-management

# Production (pinned version)
podman run rabbitmq:3.12.10-management-alpine
```

---

## Challenges and Considerations

### 1. Persistent Storage Management

**Challenge:**  
Containers are ephemeral by design. Data stored inside a container is lost when the container is removed.

**Impact:**
- Message persistence requires external volume management
- Configuration changes need to be externalized
- Plugin installations must be repeatable

**Solution:**
```bash
# Create named volume for persistent data
podman volume create rabbitmq-data

# Mount volume to container
podman run -d \
  -v rabbitmq-data:/var/lib/rabbitmq \
  rabbitmq:3.12-management
```

**Best Practices:**
- Use named volumes for data persistence
- Separate volumes for data, configuration, and logs
- Regular volume backups
- Monitor volume disk usage

### 2. Network Complexity in Clustering

**Challenge:**  
Container networking requires additional configuration for inter-node communication in clusters.

**Impact:**
- Cluster nodes must discover each other
- Erlang distributed protocol requires proper hostname resolution
- Port mapping can complicate firewall rules

**Solution:**
```bash
# Create custom network for cluster
podman network create rabbitmq-cluster

# Deploy with consistent hostnames
podman run -d \
  --name rabbitmq-node1 \
  --hostname rabbitmq-node1 \
  --network rabbitmq-cluster \
  rabbitmq:3.12-management
```

**Best Practices:**
- Use custom networks for cluster communication
- Implement service discovery (Consul, etcd)
- Document port mappings clearly
- Use consistent hostname patterns

### 3. Performance Considerations

**Potential Overhead:**

| Component | Overhead | Mitigation |
|-----------|----------|------------|
| Network (NAT) | 5-10% | Use host networking for performance-critical deployments |
| Storage (overlay) | 10-15% | Use volume mounts, avoid overlay2 for data |
| CPU | < 2% | Minimal, mostly negligible |
| Memory | < 5% | Set appropriate limits, monitor closely |

**Optimization Strategies:**
```bash
# Use host networking for maximum performance
podman run --network host rabbitmq

# Direct volume mounts instead of overlay
podman run -v /data/rabbitmq:/var/lib/rabbitmq rabbitmq

# CPU pinning for consistent performance
podman run --cpuset-cpus="0-3" rabbitmq
```

### 4. Monitoring and Observability

**Challenge:**  
Traditional monitoring tools may not have visibility into containerized workloads.

**Impact:**
- Standard monitoring may miss container-specific metrics
- Log aggregation requires container-aware configuration
- Health checks need container runtime integration

**Solution:**
- Use Podman's built-in health checks
- Export metrics to Prometheus
- Centralized logging with container log drivers
- Container-aware monitoring (cAdvisor, Podman stats)

### 5. Clustering Complexity

**Challenge:**  
RabbitMQ clustering requires shared Erlang cookie and proper node discovery.

**Impact:**
- Cookie synchronization across containers
- DNS or hosts file configuration
- Cluster formation timing issues

**Solution:**
```bash
# Shared Erlang cookie via volume
echo "SHARED_SECRET_COOKIE" > erlang.cookie
chmod 600 erlang.cookie

podman run -d \
  -v $(pwd)/erlang.cookie:/var/lib/rabbitmq/.erlang.cookie:ro \
  rabbitmq:3.12-management
```

**Best Practices:**
- Use secrets management (Podman secrets)
- Implement health checks before joining cluster
- Use orchestration tools for large clusters
- Document cluster formation sequence

### 6. Security Considerations

**Container-Specific Risks:**

| Risk | Impact | Mitigation |
|------|--------|------------|
| Privilege Escalation | High | Run rootless containers |
| Image Vulnerabilities | Medium | Use official images, scan regularly |
| Network Exposure | Medium | Limit port exposure, use firewalls |
| Secret Management | High | Use Podman secrets, not environment variables |

**Security Best Practices:**
```bash
# Run as rootless
podman run --user 1000:1000 rabbitmq

# Read-only root filesystem
podman run --read-only rabbitmq

# Drop all capabilities
podman run --cap-drop=ALL rabbitmq

# Security scanning
podman scan rabbitmq:3.12-management
```

### 7. Windows Compatibility

**Challenge:**  
Podman on Windows requires WSL2 or virtualization, adding complexity.

**Impact:**
- Additional layer between container and hardware
- Performance overhead on Windows hosts
- Increased memory requirements

**Recommendation:**
- For Windows environments, consider Windows containers or VMs
- Use Linux hosts for production RabbitMQ containers
- Windows suitable for development/testing only

---

## Prerequisites

### System Requirements

#### Linux Host (Recommended)

**Operating System:**
- Red Hat Enterprise Linux 8.x or later
- CentOS Stream 8 or later
- Fedora 33 or later
- Ubuntu 20.04 LTS or later

**Minimum Hardware:**
- CPU: 2 cores (4+ recommended for production)
- RAM: 4 GB (8 GB+ recommended for production)
- Disk: 20 GB (50 GB+ for production with persistent data)
- Network: 1 Gbps network interface

**Recommended Production Hardware:**
- CPU: 8+ cores
- RAM: 16-32 GB
- Disk: 100 GB+ SSD/NVMe
- Network: 10 Gbps network interface

#### Windows Host (Development Only)

**Requirements:**
- Windows 10/11 Pro or Enterprise (for WSL2)
- WSL2 enabled
- Minimum 8 GB RAM (16 GB+ recommended)
- Virtualization enabled in BIOS

### Software Requirements

**Podman Installation:**
```bash
# RHEL/CentOS
sudo dnf install -y podman podman-compose

# Ubuntu/Debian
sudo apt-get update
sudo apt-get install -y podman

# Verify installation
podman --version
```

**Additional Tools:**
```bash
# Podman Compose (Docker Compose compatibility)
sudo pip3 install podman-compose

# Network tools
sudo dnf install -y bind-utils net-tools

# Monitoring tools
sudo dnf install -y htop iotop
```

### Network Requirements

**Required Ports:**

| Port | Protocol | Purpose | Access |
|------|----------|---------|--------|
| 5672 | TCP | AMQP client connections | External |
| 15672 | TCP | Management UI/API | Internal/External |
| 25672 | TCP | Inter-node communication | Internal only |
| 4369 | TCP | EPMD (Erlang Port Mapper) | Internal only |

**Firewall Configuration:**
```bash
# RHEL/CentOS (firewalld)
sudo firewall-cmd --permanent --add-port=5672/tcp
sudo firewall-cmd --permanent --add-port=15672/tcp
sudo firewall-cmd --permanent --add-port=25672/tcp
sudo firewall-cmd --permanent --add-port=4369/tcp
sudo firewall-cmd --reload

# Ubuntu (ufw)
sudo ufw allow 5672/tcp
sudo ufw allow 15672/tcp
sudo ufw allow 25672/tcp
sudo ufw allow 4369/tcp
```

### Storage Requirements

**Volume Configuration:**
```bash
# Create directories for persistent data
sudo mkdir -p /opt/rabbitmq/{data,logs,config}
sudo chown -R 999:999 /opt/rabbitmq  # RabbitMQ user in container
```

**Recommended Storage Layout:**
- `/opt/rabbitmq/data` - RabbitMQ database and message store (50+ GB)
- `/opt/rabbitmq/logs` - Application logs (10+ GB)
- `/opt/rabbitmq/config` - Configuration files (< 1 GB)

---

## Installation Guide

### Installing Podman

#### Red Hat Enterprise Linux / CentOS

```bash
# Enable required repositories
sudo subscription-manager repos --enable rhel-8-for-x86_64-appstream-rpms

# Install Podman
sudo dnf install -y podman podman-docker

# Enable rootless networking
sudo dnf install -y slirp4netns

# Verify installation
podman info
```

#### Ubuntu / Debian

```bash
# Update package index
sudo apt-get update

# Install Podman
sudo apt-get -y install podman

# Install additional tools
sudo apt-get -y install buildah skopeo

# Verify installation
podman version
```

#### Fedora

```bash
# Podman is pre-installed on Fedora 35+
# If not installed:
sudo dnf install -y podman

# Update to latest version
sudo dnf upgrade -y podman

# Verify
podman version
```

### Post-Installation Configuration

#### Configure Rootless Podman

```bash
# Enable user namespaces
echo "user.max_user_namespaces=28633" | sudo tee -a /etc/sysctl.conf
sudo sysctl -p

# Configure subuid/subgid for current user
sudo usermod --add-subuids 100000-165535 --add-subgids 100000-165535 $(whoami)

# Verify configuration
podman system migrate
podman info | grep -i rootless
```

#### Configure Storage

```bash
# Edit storage configuration
mkdir -p ~/.config/containers
cat > ~/.config/containers/storage.conf << EOF
[storage]
driver = "overlay"
runroot = "/run/user/$(id -u)/containers"
graphroot = "/home/$(whoami)/.local/share/containers/storage"

[storage.options]
mount_program = "/usr/bin/fuse-overlayfs"
EOF
```

#### Configure Registries

```bash
# Configure container registries
cat > ~/.config/containers/registries.conf << EOF
[registries.search]
registries = ['docker.io', 'quay.io']

[registries.insecure]
registries = []

[registries.block]
registries = []
EOF
```

### Verify Installation

```bash
# Check Podman version
podman --version

# Check system info
podman info

# Test with hello-world
podman run hello-world

# Check for any warnings
podman system check
```

---

## Single Instance Deployment

### Basic Deployment

#### Quick Start

```bash
# Pull RabbitMQ image with management plugin
podman pull docker.io/rabbitmq:3.12-management

# Run basic instance
podman run -d \
  --name rabbitmq \
  -p 5672:5672 \
  -p 15672:15672 \
  rabbitmq:3.12-management

# Verify container is running
podman ps

# Check logs
podman logs rabbitmq

# Access management UI
# http://localhost:15672 (guest/guest)
```

#### Production-Ready Single Instance

```bash
# Create persistent volumes
podman volume create rabbitmq-data
podman volume create rabbitmq-logs
podman volume create rabbitmq-config

# Create configuration file
mkdir -p ~/rabbitmq-config
cat > ~/rabbitmq-config/rabbitmq.conf << EOF
# Memory settings
vm_memory_high_watermark.relative = 0.6
vm_memory_high_watermark_paging_ratio = 0.75

# Disk space monitoring
disk_free_limit.absolute = 10GB

# Connection settings
channel_max = 2048
heartbeat = 60

# Logging
log.console.level = info
log.file.level = info

# Management plugin
management.tcp.port = 15672
EOF

# Deploy with custom configuration
podman run -d \
  --name rabbitmq-prod \
  --hostname rabbitmq-prod \
  -p 5672:5672 \
  -p 15672:15672 \
  -e RABBITMQ_DEFAULT_USER=admin \
  -e RABBITMQ_DEFAULT_PASS=SecurePassword123! \
  -e RABBITMQ_DEFAULT_VHOST=/ \
  -v rabbitmq-data:/var/lib/rabbitmq \
  -v rabbitmq-logs:/var/log/rabbitmq \
  -v ~/rabbitmq-config/rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf:ro \
  --memory=4g \
  --cpus=2 \
  --restart=always \
  rabbitmq:3.12-management
```

### Configuration Options

#### Environment Variables

```bash
# Complete environment variable example
podman run -d \
  --name rabbitmq \
  -e RABBITMQ_DEFAULT_USER=admin \
  -e RABBITMQ_DEFAULT_PASS=SecurePass123! \
  -e RABBITMQ_DEFAULT_VHOST=production \
  -e RABBITMQ_ERLANG_COOKIE=SHARED_SECRET_COOKIE \
  -e RABBITMQ_VM_MEMORY_HIGH_WATERMARK=0.6 \
  -e RABBITMQ_DISK_FREE_LIMIT=10GB \
  -e RABBITMQ_NODENAME=rabbit@rabbitmq \
  rabbitmq:3.12-management
```

**Common Environment Variables:**

| Variable | Purpose | Example |
|----------|---------|---------|
| RABBITMQ_DEFAULT_USER | Admin username | admin |
| RABBITMQ_DEFAULT_PASS | Admin password | SecurePass123! |
| RABBITMQ_DEFAULT_VHOST | Default virtual host | / or production |
| RABBITMQ_ERLANG_COOKIE | Cluster authentication | SHARED_SECRET |
| RABBITMQ_VM_MEMORY_HIGH_WATERMARK | Memory limit | 0.6 (60%) |
| RABBITMQ_DISK_FREE_LIMIT | Disk space alarm | 10GB |

#### Resource Limits

```bash
# Set resource constraints
podman run -d \
  --name rabbitmq \
  --memory=4g \              # Maximum memory
  --memory-reservation=2g \  # Soft memory limit
  --cpus=2.5 \              # CPU allocation
  --cpu-shares=1024 \       # CPU priority
  --pids-limit=4096 \       # Process limit
  rabbitmq:3.12-management
```

#### Health Checks

```bash
# Run with built-in health check
podman run -d \
  --name rabbitmq \
  --health-cmd='rabbitmq-diagnostics -q ping' \
  --health-interval=30s \
  --health-timeout=10s \
  --health-retries=3 \
  --health-start-period=60s \
  rabbitmq:3.12-management

# Check health status
podman healthcheck run rabbitmq
podman inspect rabbitmq | grep -A 10 Health
```

### Systemd Integration

#### Create Systemd Service

```bash
# Generate systemd service file
mkdir -p ~/.config/systemd/user
podman generate systemd --new --name rabbitmq \
  > ~/.config/systemd/user/rabbitmq.service

# Reload systemd
systemctl --user daemon-reload

# Enable service to start on boot
systemctl --user enable rabbitmq.service

# Manage service
systemctl --user start rabbitmq
systemctl --user status rabbitmq
systemctl --user stop rabbitmq
systemctl --user restart rabbitmq

# View logs
journalctl --user -u rabbitmq -f
```

#### Custom Systemd Service

```ini
# ~/.config/systemd/user/rabbitmq.service
[Unit]
Description=RabbitMQ Message Broker (Container)
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
Restart=always
RestartSec=10
TimeoutStartSec=0

ExecStartPre=/usr/bin/podman pull docker.io/rabbitmq:3.12-management
ExecStart=/usr/bin/podman run \
  --name rabbitmq \
  --hostname rabbitmq-prod \
  -p 5672:5672 \
  -p 15672:15672 \
  -e RABBITMQ_DEFAULT_USER=admin \
  -e RABBITMQ_DEFAULT_PASS=SecurePassword123! \
  -v rabbitmq-data:/var/lib/rabbitmq \
  -v rabbitmq-logs:/var/log/rabbitmq \
  --memory=4g \
  --cpus=2 \
  rabbitmq:3.12-management

ExecStop=/usr/bin/podman stop -t 30 rabbitmq
ExecStopPost=/usr/bin/podman rm -f rabbitmq

[Install]
WantedBy=default.target
```

---

## Cluster Deployment

### Three-Node Cluster Setup

#### Prerequisites

**Cluster Requirements:**
- Three Linux hosts (physical or virtual)
- Network connectivity between all nodes
- Synchronized time (NTP)
- Same RabbitMQ version on all nodes

**Host Configuration:**

| Hostname | IP Address | Role |
|----------|------------|------|
| rabbitmq-node1 | 10.0.1.201 | Primary |
| rabbitmq-node2 | 10.0.1.202 | Replica |
| rabbitmq-node3 | 10.0.1.203 | Replica |

#### Step 1: Prepare Shared Erlang Cookie

```bash
# Generate shared Erlang cookie (run on admin workstation)
openssl rand -base64 32 > erlang.cookie
chmod 600 erlang.cookie

# Distribute to all nodes
scp erlang.cookie user@rabbitmq-node1:/opt/rabbitmq/erlang.cookie
scp erlang.cookie user@rabbitmq-node2:/opt/rabbitmq/erlang.cookie
scp erlang.cookie user@rabbitmq-node3:/opt/rabbitmq/erlang.cookie

# Set permissions on each node
ssh user@rabbitmq-node1 "chmod 400 /opt/rabbitmq/erlang.cookie"
ssh user@rabbitmq-node2 "chmod 400 /opt/rabbitmq/erlang.cookie"
ssh user@rabbitmq-node3 "chmod 400 /opt/rabbitmq/erlang.cookie"
```

#### Step 2: Configure DNS or Hosts Files

```bash
# On each node, add all cluster nodes to /etc/hosts
sudo tee -a /etc/hosts << EOF
10.0.1.201 rabbitmq-node1
10.0.1.202 rabbitmq-node2
10.0.1.203 rabbitmq-node3
EOF
```

#### Step 3: Create Podman Network

```bash
# On each node, create custom network
podman network create rabbitmq-cluster --subnet 10.88.0.0/16
```

#### Step 4: Deploy First Node (Primary)

```bash
# On rabbitmq-node1
podman run -d \
  --name rabbitmq \
  --hostname rabbitmq-node1 \
  --network rabbitmq-cluster \
  -p 5672:5672 \
  -p 15672:15672 \
  -p 25672:25672 \
  -p 4369:4369 \
  -e RABBITMQ_ERLANG_COOKIE_FILE=/var/lib/rabbitmq/.erlang.cookie \
  -e RABBITMQ_NODENAME=rabbit@rabbitmq-node1 \
  -e RABBITMQ_DEFAULT_USER=admin \
  -e RABBITMQ_DEFAULT_PASS=ClusterPassword123! \
  -v /opt/rabbitmq/erlang.cookie:/var/lib/rabbitmq/.erlang.cookie:ro \
  -v rabbitmq-data:/var/lib/rabbitmq \
  --memory=8g \
  --cpus=4 \
  rabbitmq:3.12-management

# Wait for RabbitMQ to start
sleep 30

# Verify node is running
podman exec rabbitmq rabbitmqctl status
```

#### Step 5: Deploy Second Node

```bash
# On rabbitmq-node2
podman run -d \
  --name rabbitmq \
  --hostname rabbitmq-node2 \
  --network rabbitmq-cluster \
  --add-host rabbitmq-node1:10.0.1.201 \
  --add-host rabbitmq-node3:10.0.1.203 \
  -p 5672:5672 \
  -p 15672:15672 \
  -p 25672:25672 \
  -p 4369:4369 \
  -e RABBITMQ_ERLANG_COOKIE_FILE=/var/lib/rabbitmq/.erlang.cookie \
  -e RABBITMQ_NODENAME=rabbit@rabbitmq-node2 \
  -v /opt/rabbitmq/erlang.cookie:/var/lib/rabbitmq/.erlang.cookie:ro \
  -v rabbitmq-data:/var/lib/rabbitmq \
  --memory=8g \
  --cpus=4 \
  rabbitmq:3.12-management

# Wait for startup
sleep 30

# Join cluster
podman exec rabbitmq rabbitmqctl stop_app
podman exec rabbitmq rabbitmqctl reset
podman exec rabbitmq rabbitmqctl join_cluster rabbit@rabbitmq-node1
podman exec rabbitmq rabbitmqctl start_app

# Verify cluster status
podman exec rabbitmq rabbitmqctl cluster_status
```

#### Step 6: Deploy Third Node

```bash
# On rabbitmq-node3
podman run -d \
  --name rabbitmq \
  --hostname rabbitmq-node3 \
  --network rabbitmq-cluster \
  --add-host rabbitmq-node1:10.0.1.201 \
  --add-host rabbitmq-node2:10.0.1.202 \
  -p 5672:5672 \
  -p 15672:15672 \
  -p 25672:25672 \
  -p 4369:4369 \
  -e RABBITMQ_ERLANG_COOKIE_FILE=/var/lib/rabbitmq/.erlang.cookie \
  -e RABBITMQ_NODENAME=rabbit@rabbitmq-node3 \
  -v /opt/rabbitmq/erlang.cookie:/var/lib/rabbitmq/.erlang.cookie:ro \
  -v rabbitmq-data:/var/lib/rabbitmq \
  --memory=8g \
  --cpus=4 \
  rabbitmq:3.12-management

# Wait for startup
sleep 30

# Join cluster
podman exec rabbitmq rabbitmqctl stop_app
podman exec rabbitmq rabbitmqctl reset
podman exec rabbitmq rabbitmqctl join_cluster rabbit@rabbitmq-node1
podman exec rabbitmq rabbitmqctl start_app

# Verify cluster status
podman exec rabbitmq rabbitmqctl cluster_status
```

#### Step 7: Configure High Availability

```bash
# On any node, set HA policy
podman exec rabbitmq rabbitmqctl set_policy ha-all \
  ".*" '{"ha-mode":"all","ha-sync-mode":"automatic"}' \
  --priority 0 \
  --apply-to queues

# Verify policy
podman exec rabbitmq rabbitmqctl list_policies
```

### Using Podman Compose for Cluster

#### Create docker-compose.yml

```yaml
# rabbitmq-cluster-compose.yml
version: '3.8'

services:
  rabbitmq-node1:
    image: rabbitmq:3.12-management
    hostname: rabbitmq-node1
    container_name: rabbitmq-node1
    environment:
      - RABBITMQ_ERLANG_COOKIE=SHARED_SECRET_COOKIE_CHANGE_ME
      - RABBITMQ_NODENAME=rabbit@rabbitmq-node1
      - RABBITMQ_DEFAULT_USER=admin
      - RABBITMQ_DEFAULT_PASS=SecurePassword123!
    volumes:
      - rabbitmq1-data:/var/lib/rabbitmq
      - ./rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf:ro
    ports:
      - "5672:5672"
      - "15672:15672"
      - "25672:25672"
    networks:
      - rabbitmq-cluster
    deploy:
      resources:
        limits:
          cpus: '4'
          memory: 8G
    healthcheck:
      test: ["CMD", "rabbitmq-diagnostics", "-q", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3

  rabbitmq-node2:
    image: rabbitmq:3.12-management
    hostname: rabbitmq-node2
    container_name: rabbitmq-node2
    environment:
      - RABBITMQ_ERLANG_COOKIE=SHARED_SECRET_COOKIE_CHANGE_ME
      - RABBITMQ_NODENAME=rabbit@rabbitmq-node2
    volumes:
      - rabbitmq2-data:/var/lib/rabbitmq
      - ./rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf:ro
    ports:
      - "5673:5672"
      - "15673:15672"
    networks:
      - rabbitmq-cluster
    depends_on:
      - rabbitmq-node1
    deploy:
      resources:
        limits:
          cpus: '4'
          memory: 8G
    healthcheck:
      test: ["CMD", "rabbitmq-diagnostics", "-q", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3

  rabbitmq-node3:
    image: rabbitmq:3.12-management
    hostname: rabbitmq-node3
    container_name: rabbitmq-node3
    environment:
      - RABBITMQ_ERLANG_COOKIE=SHARED_SECRET_COOKIE_CHANGE_ME
      - RABBITMQ_NODENAME=rabbit@rabbitmq-node3
    volumes:
      - rabbitmq3-data:/var/lib/rabbitmq
      - ./rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf:ro
    ports:
      - "5674:5672"
      - "15674:15672"
    networks:
      - rabbitmq-cluster
    depends_on:
      - rabbitmq-node1
    deploy:
      resources:
        limits:
          cpus: '4'
          memory: 8G
    healthcheck:
      test: ["CMD", "rabbitmq-diagnostics", "-q", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3

volumes:
  rabbitmq1-data:
  rabbitmq2-data:
  rabbitmq3-data:

networks:
  rabbitmq-cluster:
    driver: bridge
```

#### Deploy with Podman Compose

```bash
# Start cluster
podman-compose -f rabbitmq-cluster-compose.yml up -d

# Join nodes to cluster
sleep 60  # Wait for all nodes to start

# Join node2 to cluster
podman exec rabbitmq-node2 rabbitmqctl stop_app
podman exec rabbitmq-node2 rabbitmqctl join_cluster rabbit@rabbitmq-node1
podman exec rabbitmq-node2 rabbitmqctl start_app

# Join node3 to cluster
podman exec rabbitmq-node3 rabbitmqctl stop_app
podman exec rabbitmq-node3 rabbitmqctl join_cluster rabbit@rabbitmq-node1
podman exec rabbitmq-node3 rabbitmqctl start_app

# Verify cluster
podman exec rabbitmq-node1 rabbitmqctl cluster_status

# Set HA policy
podman exec rabbitmq-node1 rabbitmqctl set_policy ha-all \
  ".*" '{"ha-mode":"all"}'

# Check status
podman-compose -f rabbitmq-cluster-compose.yml ps
```

---

## Production Configuration

### Advanced RabbitMQ Configuration

#### Complete rabbitmq.conf

```ini
# /opt/rabbitmq/config/rabbitmq.conf

## Clustering
cluster_formation.peer_discovery_backend = rabbit_peer_discovery_classic_config
cluster_formation.classic_config.nodes.1 = rabbit@rabbitmq-node1
cluster_formation.classic_config.nodes.2 = rabbit@rabbitmq-node2
cluster_formation.classic_config.nodes.3 = rabbit@rabbitmq-node3

## Memory Management
vm_memory_high_watermark.relative = 0.6
vm_memory_high_watermark_paging_ratio = 0.75
total_memory_available_override_value = 8GB

## Disk Space
disk_free_limit.absolute = 10GB

## Connection and Channel Limits
channel_max = 2048
connection_max = 2000

## Networking
listeners.tcp.default = 5672
management.tcp.port = 15672
management.tcp.ip = 0.0.0.0

## SSL/TLS (if needed)
# listeners.ssl.default = 5671
# ssl_options.cacertfile = /path/to/ca_certificate.pem
# ssl_options.certfile = /path/to/server_certificate.pem
# ssl_options.keyfile = /path/to/server_key.pem
# ssl_options.verify = verify_peer
# ssl_options.fail_if_no_peer_cert = true

## Heartbeat
heartbeat = 60

## Queue Settings
queue_master_locator = min-masters

## Logging
log.console = true
log.console.level = info
log.file = /var/log/rabbitmq/rabbit.log
log.file.level = info
log.file.rotation.count = 5
log.file.rotation.size = 10485760

## Management Plugin
management.load_definitions = /etc/rabbitmq/definitions.json

## Performance Tuning
collect_statistics = coarse
collect_statistics_interval = 5000
```

#### Definitions File (definitions.json)

```json
{
  "users": [
    {
      "name": "admin",
      "password_hash": "hashed_password_here",
      "hashing_algorithm": "rabbit_password_hashing_sha256",
      "tags": "administrator"
    },
    {
      "name": "lenel_user",
      "password_hash": "hashed_password_here",
      "hashing_algorithm": "rabbit_password_hashing_sha256",
      "tags": ""
    }
  ],
  "vhosts": [
    {
      "name": "/"
    },
    {
      "name": "lenel_production"
    }
  ],
  "permissions": [
    {
      "user": "admin",
      "vhost": "/",
      "configure": ".*",
      "write": ".*",
      "read": ".*"
    },
    {
      "user": "lenel_user",
      "vhost": "lenel_production",
      "configure": ".*",
      "write": ".*",
      "read": ".*"
    }
  ],
  "policies": [
    {
      "vhost": "/",
      "name": "ha-all",
      "pattern": ".*",
      "apply-to": "queues",
      "definition": {
        "ha-mode": "all",
        "ha-sync-mode": "automatic"
      },
      "priority": 0
    }
  ]
}
```

### Security Hardening

#### Rootless Container Configuration

```bash
# Run as rootless (recommended)
# Ensure user namespaces configured
podman unshare cat /proc/self/uid_map

# Run container as specific UID
podman run -d \
  --name rabbitmq \
  --user 999:999 \
  rabbitmq:3.12-management
```

#### Read-Only Root Filesystem

```bash
# Run with read-only root filesystem
podman run -d \
  --name rabbitmq \
  --read-only \
  --tmpfs /tmp \
  -v rabbitmq-data:/var/lib/rabbitmq \
  rabbitmq:3.12-management
```

#### Security Options

```bash
# Apply security hardening
podman run -d \
  --name rabbitmq \
  --security-opt=no-new-privileges \
  --security-opt label=type:container_runtime_t \
  --cap-drop=ALL \
  --cap-add=CHOWN \
  --cap-add=SETGID \
  --cap-add=SETUID \
  --cap-add=NET_BIND_SERVICE \
  rabbitmq:3.12-management
```

#### Image Scanning

```bash
# Scan image for vulnerabilities
podman scan rabbitmq:3.12-management

# Use minimal base image
podman pull rabbitmq:3.12-management-alpine

# Verify image signature (if available)
podman image trust set -f /path/to/policy.json docker.io/rabbitmq
```

### Resource Management

#### CPU Management

```bash
# CPU pinning for consistent performance
podman run -d \
  --name rabbitmq \
  --cpuset-cpus="0-3" \
  --cpu-shares=2048 \
  rabbitmq:3.12-management

# CPU quota (percentage of total CPU)
podman run -d \
  --name rabbitmq \
  --cpus=2.5 \
  rabbitmq:3.12-management
```

#### Memory Management

```bash
# Memory limits with reservation
podman run -d \
  --name rabbitmq \
  --memory=8g \
  --memory-reservation=6g \
  --memory-swap=10g \
  --oom-kill-disable \
  rabbitmq:3.12-management
```

#### I/O Management

```bash
# Limit disk I/O
podman run -d \
  --name rabbitmq \
  --device-read-bps /dev/sda:100mb \
  --device-write-bps /dev/sda:100mb \
  rabbitmq:3.12-management
```

---

## Backup and Recovery

### Data Backup Strategies

#### Volume-Based Backup

```bash
# Stop container gracefully
podman stop -t 30 rabbitmq

# Export volume data
podman volume export rabbitmq-data > rabbitmq-data-backup-$(date +%Y%m%d-%H%M%S).tar

# Restart container
podman start rabbitmq

# Alternative: Backup without stopping (snapshot if using LVM)
lvcreate -L 10G -s -n rabbitmq-snapshot /dev/vg0/rabbitmq-volume
```

#### Configuration Backup

```bash
# Backup configuration
mkdir -p ~/rabbitmq-backups/$(date +%Y%m%d)

# Export definitions
podman exec rabbitmq rabbitmqadmin export \
  ~/rabbitmq-backups/$(date +%Y%m%d)/definitions.json

# Backup container configuration
podman inspect rabbitmq > ~/rabbitmq-backups/$(date +%Y%m%d)/container-config.json

# Backup rabbitmq.conf
cp /opt/rabbitmq/config/rabbitmq.conf ~/rabbitmq-backups/$(date +%Y%m%d)/
```

#### Automated Backup Script

```bash
#!/bin/bash
# rabbitmq-backup.sh

BACKUP_DIR="/opt/backups/rabbitmq"
DATE=$(date +%Y%m%d-%H%M%S)
BACKUP_PATH="$BACKUP_DIR/$DATE"
RETENTION_DAYS=7

# Create backup directory
mkdir -p "$BACKUP_PATH"

# Export RabbitMQ definitions
echo "Exporting RabbitMQ definitions..."
podman exec rabbitmq rabbitmqadmin export "$BACKUP_PATH/definitions.json"

# Backup container configuration
echo "Backing up container configuration..."
podman inspect rabbitmq > "$BACKUP_PATH/container-config.json"

# Backup volume data
echo "Backing up volume data..."
podman volume export rabbitmq-data > "$BACKUP_PATH/volume-data.tar"

# Compress backup
echo "Compressing backup..."
cd "$BACKUP_DIR"
tar -czf "rabbitmq-backup-$DATE.tar.gz" "$DATE"
rm -rf "$DATE"

# Remove old backups
echo "Cleaning old backups..."
find "$BACKUP_DIR" -name "rabbitmq-backup-*.tar.gz" -mtime +$RETENTION_DAYS -delete

echo "Backup completed: rabbitmq-backup-$DATE.tar.gz"
```

**Schedule with cron:**
```bash
# Add to crontab
crontab -e

# Daily backup at 2 AM
0 2 * * * /opt/scripts/rabbitmq-backup.sh >> /var/log/rabbitmq-backup.log 2>&1
```

### Disaster Recovery

#### Full Recovery Procedure

```bash
# Step 1: Stop existing container (if any)
podman stop rabbitmq
podman rm rabbitmq

# Step 2: Clean volumes (CAUTION: This deletes all data)
podman volume rm rabbitmq-data

# Step 3: Create new volume
podman volume create rabbitmq-data

# Step 4: Restore volume data
podman volume import rabbitmq-data < rabbitmq-data-backup-20260114-020000.tar

# Step 5: Start container with restored data
podman run -d \
  --name rabbitmq \
  --hostname rabbitmq-prod \
  -p 5672:5672 \
  -p 15672:15672 \
  -v rabbitmq-data:/var/lib/rabbitmq \
  -v /opt/rabbitmq/config/rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf:ro \
  rabbitmq:3.12-management

# Step 6: Verify recovery
podman logs -f rabbitmq

# Step 7: Check cluster status (if clustered)
podman exec rabbitmq rabbitmqctl cluster_status

# Step 8: Import definitions (if needed)
podman exec rabbitmq rabbitmqadmin import /path/to/definitions.json
```

#### Point-in-Time Recovery

```bash
# List available backups
ls -lh /opt/backups/rabbitmq/

# Extract specific backup
tar -xzf /opt/backups/rabbitmq/rabbitmq-backup-20260114-020000.tar.gz

# Restore from specific point in time
podman volume import rabbitmq-data < 20260114-020000/volume-data.tar

# Start container
podman start rabbitmq
```

---

## Monitoring and Maintenance

### Built-in Monitoring

#### Podman Stats

```bash
# Real-time resource monitoring
podman stats rabbitmq

# Output:
# CONTAINER   CPU %   MEM USAGE / LIMIT   MEM %   NET I/O           BLOCK I/O
# rabbitmq    12.5%   2.1GB / 8GB        26.25%   1.2GB / 850MB    45MB / 12MB

# JSON output for parsing
podman stats --no-stream --format json rabbitmq
```

#### Health Checks

```bash
# Check container health
podman healthcheck run rabbitmq

# View health status
podman inspect rabbitmq --format='{{.State.Health.Status}}'

# View health log
podman inspect rabbitmq | jq '.[0].State.Health'
```

#### RabbitMQ Diagnostics

```bash
# Quick health check
podman exec rabbitmq rabbitmq-diagnostics ping

# Detailed status
podman exec rabbitmq rabbitmq-diagnostics status

# Check alarms
podman exec rabbitmq rabbitmq-diagnostics alarms

# Check cluster health
podman exec rabbitmq rabbitmq-diagnostics cluster_status

# Check quorum queue status
podman exec rabbitmq rabbitmq-diagnostics quorum_status

# Memory breakdown
podman exec rabbitmq rabbitmq-diagnostics memory_breakdown
```

### Prometheus Integration

#### Enable Prometheus Plugin

```bash
# Enable prometheus plugin
podman exec rabbitmq rabbitmq-plugins enable rabbitmq_prometheus

# Verify plugin enabled
podman exec rabbitmq rabbitmq-plugins list

# Metrics endpoint available at:
# http://localhost:15692/metrics
```

#### Prometheus Configuration

```yaml
# prometheus.yml
scrape_configs:
  - job_name: 'rabbitmq'
    static_configs:
      - targets: ['rabbitmq-node1:15692', 'rabbitmq-node2:15692', 'rabbitmq-node3:15692']
    scrape_interval: 15s
    scrape_timeout: 10s
```

#### Deploy Prometheus with Podman

```bash
# Create prometheus config
mkdir -p ~/prometheus
cat > ~/prometheus/prometheus.yml << EOF
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'rabbitmq'
    static_configs:
      - targets: ['rabbitmq:15692']
EOF

# Run Prometheus
podman run -d \
  --name prometheus \
  --network rabbitmq-cluster \
  -p 9090:9090 \
  -v ~/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml:ro \
  prom/prometheus

# Access Prometheus UI: http://localhost:9090
```

### Grafana Dashboards

#### Deploy Grafana

```bash
# Run Grafana
podman run -d \
  --name grafana \
  --network rabbitmq-cluster \
  -p 3000:3000 \
  -e "GF_SECURITY_ADMIN_PASSWORD=admin" \
  grafana/grafana

# Access Grafana: http://localhost:3000 (admin/admin)
```

#### Import RabbitMQ Dashboard

1. Access Grafana at http://localhost:3000
2. Add Prometheus data source (http://prometheus:9090)
3. Import dashboard ID: 10991 (RabbitMQ-Overview)
4. Select Prometheus data source

### Log Management

#### Container Logs

```bash
# View logs
podman logs rabbitmq

# Follow logs in real-time
podman logs -f rabbitmq

# Last 100 lines
podman logs --tail 100 rabbitmq

# Logs since specific time
podman logs --since 1h rabbitmq

# Export logs
podman logs rabbitmq > rabbitmq-$(date +%Y%m%d).log
```

#### Centralized Logging

```bash
# Configure syslog driver
podman run -d \
  --name rabbitmq \
  --log-driver syslog \
  --log-opt syslog-address=udp://syslog-server:514 \
  --log-opt tag="rabbitmq" \
  rabbitmq:3.12-management

# Or JSON file with rotation
podman run -d \
  --name rabbitmq \
  --log-driver json-file \
  --log-opt max-size=100m \
  --log-opt max-file=5 \
  rabbitmq:3.12-management
```

### Maintenance Tasks

#### Update Container Image

```bash
# Pull latest image
podman pull rabbitmq:3.12-management

# Stop current container
podman stop rabbitmq

# Remove old container (keeps volumes)
podman rm rabbitmq

# Start with new image
podman run -d \
  --name rabbitmq \
  -v rabbitmq-data:/var/lib/rabbitmq \
  rabbitmq:3.12-management

# Verify version
podman exec rabbitmq rabbitmqctl version
```

#### Clean Up Resources

```bash
# Remove unused images
podman image prune -a

# Remove unused volumes
podman volume prune

# Remove stopped containers
podman container prune

# Complete system cleanup
podman system prune -a --volumes
```

#### Performance Tuning

```bash
# View resource usage
podman stats --no-stream rabbitmq

# Check memory usage details
podman exec rabbitmq rabbitmq-diagnostics memory_breakdown

# Adjust memory limits (requires restart)
podman update --memory=16g rabbitmq

# Note: podman update has limited support
# Better approach: Recreate container with new limits
```

---

## Troubleshooting

### Common Issues and Solutions

#### Issue 1: Container Won't Start

**Symptoms:**
- Container exits immediately after start
- "Error response from daemon" messages

**Diagnosis:**
```bash
# Check container logs
podman logs rabbitmq

# Check container status
podman ps -a

# Inspect container
podman inspect rabbitmq
```

**Common Causes & Solutions:**

**Port Conflict:**
```bash
# Check port usage
sudo ss -tulpn | grep 5672

# Use different port
podman run -d --name rabbitmq -p 5673:5672 rabbitmq
```

**Permission Issues:**
```bash
# Fix volume permissions
sudo chown -R 999:999 /opt/rabbitmq/data

# Or run with correct user
podman run -d --user 999:999 rabbitmq
```

**Memory Limits:**
```bash
# Check system memory
free -h

# Reduce memory limit
podman run -d --memory=2g rabbitmq
```

#### Issue 2: Cluster Formation Fails

**Symptoms:**
- Nodes can't join cluster
- "Cluster name mismatch" errors
- "Authentication failed" errors

**Diagnosis:**
```bash
# Check Erlang cookie matches
podman exec rabbitmq-node1 cat /var/lib/rabbitmq/.erlang.cookie
podman exec rabbitmq-node2 cat /var/lib/rabbitmq/.erlang.cookie

# Check network connectivity
podman exec rabbitmq-node2 ping rabbitmq-node1

# Check EPMD running
podman exec rabbitmq-node1 epmd -names
```

**Solutions:**

**Cookie Mismatch:**
```bash
# Ensure same cookie on all nodes
echo "SHARED_COOKIE" > erlang.cookie
chmod 600 erlang.cookie

# Recreate containers with correct cookie
podman run -d \
  -v $(pwd)/erlang.cookie:/var/lib/rabbitmq/.erlang.cookie:ro \
  rabbitmq
```

**DNS/Network Issues:**
```bash
# Add hosts entries
podman run -d \
  --add-host rabbitmq-node1:10.0.1.201 \
  --add-host rabbitmq-node2:10.0.1.202 \
  rabbitmq

# Or use custom network
podman network create rabbitmq-cluster
```

**Reset and Rejoin:**
```bash
# On problematic node
podman exec rabbitmq rabbitmqctl stop_app
podman exec rabbitmq rabbitmqctl reset
podman exec rabbitmq rabbitmqctl join_cluster rabbit@rabbitmq-node1
podman exec rabbitmq rabbitmqctl start_app
```

#### Issue 3: High Memory Usage

**Symptoms:**
- Container using excessive memory
- OOM (Out of Memory) kills
- Performance degradation

**Diagnosis:**
```bash
# Check memory usage
podman stats rabbitmq

# RabbitMQ memory breakdown
podman exec rabbitmq rabbitmq-diagnostics memory_breakdown

# Check alarms
podman exec rabbitmq rabbitmq-diagnostics alarms
```

**Solutions:**

**Adjust Memory Settings:**
```ini
# rabbitmq.conf
vm_memory_high_watermark.relative = 0.5  # Lower threshold
vm_memory_high_watermark_paging_ratio = 0.5
```

**Increase Container Memory:**
```bash
# Restart with more memory
podman stop rabbitmq
podman rm rabbitmq
podman run -d --memory=16g rabbitmq
```

**Clear Queue Backlog:**
```bash
# Identify large queues
podman exec rabbitmq rabbitmqctl list_queues name messages

# Purge specific queue
podman exec rabbitmq rabbitmqctl purge_queue queue_name
```

#### Issue 4: Performance Issues

**Symptoms:**
- Slow message processing
- High latency
- CPU saturation

**Diagnosis:**
```bash
# Check resource usage
podman stats rabbitmq

# Check queue status
podman exec rabbitmq rabbitmqctl list_queues name messages consumers message_rates

# Check connection status
podman exec rabbitmq rabbitmqctl list_connections
```

**Solutions:**

**CPU Allocation:**
```bash
# Allocate more CPUs
podman run -d --cpus=8 rabbitmq
```

**Network Performance:**
```bash
# Use host networking for best performance
podman run -d --network host rabbitmq
```

**Storage Performance:**
```bash
# Use direct volume mount instead of overlay
podman run -d \
  -v /fast/ssd/rabbitmq:/var/lib/rabbitmq \
  rabbitmq
```

#### Issue 5: Connection Refused

**Symptoms:**
- Clients can't connect to RabbitMQ
- "Connection refused" errors
- Timeout errors

**Diagnosis:**
```bash
# Check if container is running
podman ps | grep rabbitmq

# Check port mapping
podman port rabbitmq

# Test connectivity
telnet localhost 5672

# Check firewall
sudo firewall-cmd --list-ports
```

**Solutions:**

**Verify Port Mapping:**
```bash
# Correct port mapping
podman run -d -p 5672:5672 -p 15672:15672 rabbitmq
```

**Firewall Configuration:**
```bash
# Open required ports
sudo firewall-cmd --permanent --add-port=5672/tcp
sudo firewall-cmd --permanent --add-port=15672/tcp
sudo firewall-cmd --reload
```

**Check Container Network:**
```bash
# Inspect network
podman network inspect bridge

# Use host networking if needed
podman run -d --network host rabbitmq
```

### Diagnostic Commands Reference

#### Container Diagnostics

```bash
# Container status
podman ps -a
podman inspect rabbitmq
podman logs rabbitmq
podman stats rabbitmq

# Container processes
podman top rabbitmq

# Container filesystem
podman exec rabbitmq ls -lh /var/lib/rabbitmq

# Container network
podman port rabbitmq
podman inspect rabbitmq --format='{{.NetworkSettings.IPAddress}}'
```

#### RabbitMQ Diagnostics

```bash
# Status and health
podman exec rabbitmq rabbitmqctl status
podman exec rabbitmq rabbitmq-diagnostics ping
podman exec rabbitmq rabbitmq-diagnostics check_running
podman exec rabbitmq rabbitmq-diagnostics check_local_alarms

# Cluster information
podman exec rabbitmq rabbitmqctl cluster_status
podman exec rabbitmq rabbitmq-diagnostics cluster_status

# Resource information
podman exec rabbitmq rabbitmq-diagnostics memory_breakdown
podman exec rabbitmq rabbitmq-diagnostics environment

# Queue and connection information
podman exec rabbitmq rabbitmqctl list_queues
podman exec rabbitmq rabbitmqctl list_connections
podman exec rabbitmq rabbitmqctl list_channels
podman exec rabbitmq rabbitmqctl list_consumers
```

---

## Migration from VM to Container

### Pre-Migration Assessment

#### Inventory Current Environment

```bash
# Document current configuration
rabbitmqctl environment > rabbitmq-env-$(date +%Y%m%d).txt
rabbitmqctl report > rabbitmq-report-$(date +%Y%m%d).txt

# Export definitions
rabbitmqadmin export rabbitmq-definitions.json

# Document queues
rabbitmqctl list_queues name durable auto_delete > queues.txt

# Document users
rabbitmqctl list_users > users.txt

# Document vhosts
rabbitmqctl list_vhosts > vhosts.txt

# Document policies
rabbitmqctl list_policies > policies.txt
```

#### Validate Prerequisites

**Checklist:**
- [ ] Podman installed and tested on target hosts
- [ ] Sufficient storage for volume data
- [ ] Network connectivity verified
- [ ] Firewall rules planned
- [ ] Backup of current system completed
- [ ] Rollback plan documented
- [ ] Maintenance window scheduled

### Migration Steps

#### Step 1: Set Up Test Environment

```bash
# Create test container
podman run -d \
  --name rabbitmq-test \
  -p 5673:5672 \
  -p 15673:15672 \
  rabbitmq:3.12-management

# Import definitions to test
podman cp rabbitmq-definitions.json rabbitmq-test:/tmp/
podman exec rabbitmq-test rabbitmqadmin import /tmp/rabbitmq-definitions.json

# Test connectivity and functionality
# Run application tests against test instance
```

#### Step 2: Backup Production

```bash
# Stop production RabbitMQ (maintenance window)
sudo systemctl stop rabbitmq-server

# Backup data directory
sudo tar -czf rabbitmq-data-backup-$(date +%Y%m%d).tar.gz \
  /var/lib/rabbitmq

# Backup configuration
sudo cp -r /etc/rabbitmq /opt/backups/rabbitmq-config-$(date +%Y%m%d)

# Export definitions
sudo rabbitmqadmin export /opt/backups/definitions-$(date +%Y%m%d).json
```

#### Step 3: Deploy Container

```bash
# Create volumes
podman volume create rabbitmq-data

# Import existing data (optional)
# sudo tar -xzf rabbitmq-data-backup-20260114.tar.gz -C /tmp
# sudo cp -r /tmp/var/lib/rabbitmq/* $(podman volume inspect rabbitmq-data --format '{{.Mountpoint}}')

# Deploy production container
podman run -d \
  --name rabbitmq \
  --hostname rabbitmq-prod \
  -p 5672:5672 \
  -p 15672:15672 \
  -e RABBITMQ_DEFAULT_USER=admin \
  -e RABBITMQ_DEFAULT_PASS=SecurePassword123! \
  -v rabbitmq-data:/var/lib/rabbitmq \
  -v /opt/rabbitmq/config/rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf:ro \
  --memory=8g \
  --cpus=4 \
  --restart=always \
  rabbitmq:3.12-management

# Wait for startup
sleep 60

# Import definitions
podman cp /opt/backups/definitions-20260114.json rabbitmq:/tmp/
podman exec rabbitmq rabbitmqadmin import /tmp/definitions-20260114.json

# Create systemd service
podman generate systemd --new --name rabbitmq \
  > ~/.config/systemd/user/rabbitmq.service
systemctl --user enable rabbitmq.service
```

#### Step 4: Update Client Configuration

```bash
# Update connection strings in applications
# Old: amqp://rabbitmq-vm.domain.com:5672
# New: amqp://rabbitmq-container.domain.com:5672

# Or use same hostname with DNS update
# Update DNS A record to point to container host
```

#### Step 5: Validate and Monitor

```bash
# Check cluster status
podman exec rabbitmq rabbitmqctl status

# Verify queues
podman exec rabbitmq rabbitmqctl list_queues

# Verify users
podman exec rabbitmq rabbitmqctl list_users

# Monitor logs
podman logs -f rabbitmq

# Monitor resource usage
podman stats rabbitmq

# Test application connectivity
# Run application health checks
```

#### Step 6: Decommission VM

```bash
# After successful validation period (e.g., 1 week):

# Stop VM RabbitMQ service
sudo systemctl stop rabbitmq-server
sudo systemctl disable rabbitmq-server

# Archive VM data
sudo tar -czf rabbitmq-vm-final-backup-$(date +%Y%m%d).tar.gz \
  /var/lib/rabbitmq /etc/rabbitmq

# Move archive to long-term storage

# Document completion
echo "Migration completed on $(date)" > migration-complete.txt
```

### Rollback Procedure

**If issues occur during migration:**

```bash
# Step 1: Stop container
podman stop rabbitmq
podman rm rabbitmq

# Step 2: Restart VM RabbitMQ
sudo systemctl start rabbitmq-server

# Step 3: Restore data if needed
sudo rm -rf /var/lib/rabbitmq
sudo tar -xzf rabbitmq-data-backup-20260114.tar.gz -C /

# Step 4: Verify service
sudo rabbitmqctl status

# Step 5: Revert DNS/client configurations

# Step 6: Document issues for retry
```

---

## Comparison: VMs vs Containers

### Feature Comparison

| Feature | Virtual Machine | Podman Container |
|---------|----------------|------------------|
| **Deployment Time** | 1-2 hours | 10-15 minutes |
| **Resource Overhead** | 2-4 GB (OS) | < 100 MB (runtime) |
| **Boot Time** | 2-5 minutes | 5-10 seconds |
| **Isolation** | Strong (hypervisor) | Good (namespaces) |
| **Portability** | Low (VM images) | High (container images) |
| **Density** | 5-10 per host | 50-100 per host |
| **Backup Size** | 20-40 GB | 500 MB - 2 GB |
| **Update Speed** | 30-60 minutes | 2-5 minutes |
| **Configuration Management** | Manual/Scripts | Declarative (IaC) |
| **Security** | Strong isolation | Good (rootless++) |

### Use Case Recommendations

**Use Virtual Machines When:**
- ✅ Maximum isolation required (multi-tenant environments)
- ✅ Running different operating systems
- ✅ Existing VM infrastructure and expertise
- ✅ Long-term, stable deployments
- ✅ Compliance requires VM-level isolation
- ✅ Windows host environment

**Use Podman Containers When:**
- ✅ Rapid deployment and scaling needed
- ✅ Microservices architecture
- ✅ Development/testing environments
- ✅ CI/CD pipeline integration
- ✅ Resource efficiency priority
- ✅ Infrastructure as Code approach
- ✅ Linux host environment
- ✅ Cloud-native deployments

### Cost Analysis

#### VM Deployment Costs

**Infrastructure:**
- Hypervisor licensing: $0 - $5,000/host (depending on solution)
- Hardware: Standard server costs
- Storage: ~40 GB per instance

**Operational:**
- Deployment time: 2 hours @ $100/hour = $200
- Maintenance: Higher (OS patching, hypervisor updates)
- Backup storage: ~40 GB per instance

#### Container Deployment Costs

**Infrastructure:**
- Podman: $0 (open source)
- Hardware: Same server, higher density
- Storage: ~2 GB per instance

**Operational:**
- Deployment time: 15 minutes @ $100/hour = $25
- Maintenance: Lower (image updates, automated)
- Backup storage: ~2 GB per instance

**Example ROI (10 instances):**
- VM storage: 400 GB
- Container storage: 20 GB
- Storage savings: ~95%
- Deployment time savings: ~17.5 hours
- Resource efficiency: 2-3x more instances per host

---

## Best Practices Summary

### Security Best Practices

1. **Run Rootless Containers**
   - Use rootless Podman for all deployments
   - Configure user namespaces properly
   - Avoid privileged containers

2. **Use Official Images**
   - Pull from official repositories only
   - Verify image signatures
   - Scan images for vulnerabilities

3. **Implement Secrets Management**
   - Use Podman secrets for sensitive data
   - Never store secrets in environment variables or images
   - Rotate secrets regularly

4. **Network Security**
   - Limit port exposure to necessary services only
   - Use custom networks for isolation
   - Implement firewall rules

5. **Read-Only Filesystems**
   - Run containers with read-only root filesystem
   - Mount only necessary directories as writable

### Performance Best Practices

1. **Resource Limits**
   - Set appropriate CPU and memory limits
   - Monitor resource usage regularly
   - Adjust based on workload patterns

2. **Storage Optimization**
   - Use direct volume mounts for data
   - Avoid overlay storage for high I/O workloads
   - Use fast storage (SSD/NVMe) for volumes

3. **Network Performance**
   - Use host networking for maximum performance
   - Custom networks for isolation when needed
   - Monitor network I/O patterns

4. **Container Configuration**
   - Pin CPUs for consistent performance
   - Configure memory watermarks appropriately
   - Enable only necessary RabbitMQ plugins

### Operational Best Practices

1. **Monitoring**
   - Implement comprehensive monitoring (Prometheus/Grafana)
   - Set up alerting for critical metrics
   - Monitor both container and application metrics

2. **Backup Strategy**
   - Automated daily backups
   - Test recovery procedures regularly
   - Maintain backup retention policy

3. **Documentation**
   - Document all configurations
   - Maintain runbooks for common operations
   - Keep deployment procedures updated

4. **Testing**
   - Test in non-production first
   - Implement health checks
   - Validate failover procedures

5. **Updates and Maintenance**
   - Keep images updated
   - Test updates in staging first
   - Maintain rollback capability

### Deployment Best Practices

1. **Infrastructure as Code**
   - Use Podman Compose or similar tools
   - Version control all configurations
   - Automate deployments through CI/CD

2. **High Availability**
   - Deploy at least 3 nodes for clustering
   - Use quorum queues for critical data
   - Implement proper health checks

3. **Disaster Recovery**
   - Maintain off-site backups
   - Document recovery procedures
   - Test DR procedures quarterly

4. **Capacity Planning**
   - Monitor growth trends
   - Plan for 3x current capacity
   - Regular capacity reviews

---

## Conclusion

### When to Use Containerized RabbitMQ

**Ideal Scenarios:**
- Modern, cloud-native architectures
- Development and testing environments
- Microservices deployments
- Environments requiring rapid scaling
- Infrastructure as Code workflows
- Resource-constrained environments

**Consider Alternatives When:**
- Windows-only environments
- Strict compliance requires VM isolation
- Existing VM infrastructure and expertise
- Maximum isolation priority
- Long-term, unchanging deployments

### Key Takeaways

1. **Podman offers significant advantages** over Docker for RabbitMQ deployments:
   - Rootless by default (enhanced security)
   - Native systemd integration
   - No daemon overhead
   - Pod support for clustering

2. **Resource efficiency** is a major benefit:
   - 50-80% reduction in resource overhead
   - Faster deployment (minutes vs hours)
   - Higher density (10x+ instances per host)

3. **Operational improvements** include:
   - Faster backups and recovery
   - Simplified configuration management
   - Infrastructure as Code compatibility
   - Easier testing and validation

4. **Production readiness** requires:
   - Proper persistent storage configuration
   - Resource limits and monitoring
   - Security hardening
   - Documented procedures

5. **Not without challenges**:
   - Storage persistence requires planning
   - Networking complexity in clusters
   - Performance overhead in some scenarios
   - Windows compatibility limitations

### Next Steps

**For Implementation:**
1. Set up test environment following this guide
2. Validate application compatibility
3. Performance test against requirements
4. Document custom configurations
5. Train operations team
6. Plan migration strategy
7. Execute phased rollout

**For Further Learning:**
- Podman documentation: https://docs.podman.io
- RabbitMQ documentation: https://www.rabbitmq.com/docs
- Container best practices: https://cloud.google.com/architecture/best-practices-for-building-containers
- Kubernetes migration path (if needed)

---

## Appendix: Quick Reference

### Essential Podman Commands

```bash
# Container management
podman run -d --name rabbitmq rabbitmq:3.12-management
podman ps
podman stop rabbitmq
podman start rabbitmq
podman restart rabbitmq
podman rm rabbitmq
podman logs -f rabbitmq

# Volume management
podman volume create rabbitmq-data
podman volume ls
podman volume inspect rabbitmq-data
podman volume rm rabbitmq-data

# Network management
podman network create rabbitmq-cluster
podman network ls
podman network inspect rabbitmq-cluster

# Image management
podman pull rabbitmq:3.12-management
podman images
podman rmi rabbitmq:3.12-management

# Systemd integration
podman generate systemd --new --name rabbitmq > rabbitmq.service
systemctl --user enable rabbitmq.service
systemctl --user start rabbitmq.service
```

### Essential RabbitMQ Commands

```bash
# Status and diagnostics
podman exec rabbitmq rabbitmqctl status
podman exec rabbitmq rabbitmq-diagnostics ping
podman exec rabbitmq rabbitmq-diagnostics cluster_status

# Cluster management
podman exec rabbitmq rabbitmqctl stop_app
podman exec rabbitmq rabbitmqctl join_cluster rabbit@node1
podman exec rabbitmq rabbitmqctl start_app

# Queue management
podman exec rabbitmq rabbitmqctl list_queues
podman exec rabbitmq rabbitmqctl purge_queue queue_name

# User management
podman exec rabbitmq rabbitmqctl add_user username password
podman exec rabbitmq rabbitmqctl set_user_tags username administrator
podman exec rabbitmq rabbitmqctl list_users

# Policy management
podman exec rabbitmq rabbitmqctl set_policy ha-all ".*" '{"ha-mode":"all"}'
podman exec rabbitmq rabbitmqctl list_policies
```

---

## Document Revision History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | January 14, 2026 | [Your Name] | Initial document creation |
| | | | |

---

**END OF DOCUMENT**
```

This comprehensive document covers everything you need to know about containerizing RabbitMQ with Podman, formatted perfectly for OneNote!
